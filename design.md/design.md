# Scheduling JS Events

## Prior Work

There are a number of ways that people schedule midi or other events.

### Supercollider

### CSound

CSound has a number of ways

#### Score statements

The model here is of a predefined score. There are a number of ways of making this algorithmic.

```
i 0 1 2 "blah"
```

#### Event I

You may spawn through CSound opcodes. In this case, you utilize CSound timing to pause.

### Supercollider

#### Routines

```
Routine({
  loop{
    1.wait;
  }
})
```

Here, we use the wait function to create time, much as we would na√Øvely in Python or something.

#### Tempo Clock

```
TempoClock.schedule({"do"; 1; })
```

We have a method that will call itself repeatedly provided it returns a value representing how long to wait in "beats".

#### Pattern Language

```
Pbind(
    \instrument,        \test,
    \nharms,             Pseq([4, 10, 40], inf),
    \dur,                Pseq([1, 1, 2, 1]/10, inf),
    #[freq, sustain],    Ptuple([ // assignment to multiple keys
                            Pseq( (1..16) * 50, 4),
                             Pseq([1/10, 0.5, 1, 2], inf)
                        ])
).play;
```
Here we have the data for duration spit out by a generator. We play and provide values to a dur key via generation. (Note, generators can be used in looped based or score based paradigms.)

### Max

#### Metro

Equivalent to calling a function at a predictable cadence. Function can change the timing.

#### Timepoint

Something happens at a time: the essence of a score, and yet new timepoints can be generated by said function.

####

The SDK preserves this distinction.

### Sonic Pi

#### Sleep

```
live_loop :arp do
  play thing
  sleep time
end
```

Same as others

#### Sync

Sonic Pi has a way of defining methods that are synced to the clock, not unlike SC's scheduler.

### Tidal

Tidal's beginner tutorial shows a pattern language based around cycles. As such, it is a derivative of both score and pattern approached, yet tidal has an automatic division of the cycle (which is the measure, beat, whatever.)

Tidal is also unique in being able to provide a lightweight ASCII based notation library (further highlighting its declaritive, i.e. score based, approach.)

## Summarizing Approaches

### Accumulation and Division

Some approaches involve accumulating time by adding a consistent wait, or by the accumulation of scores.

Others by dividing a cycle of set length.

### The Moment vs the Eternal Return

Max uses this approach: is it repeated function, or just one event?

### Procedure vs Declaration

The SC pattern language and tidal are more procedural, whereas sonic pi has more of a capability to represent the latter.

### Time Within vs Without

It is the difference between scheduling an event vs a function that schedules itself with different times.

## Can all of the above be represented using the Max SDK?

### Components of the SDK

#### ITM

Support tempo alignment. Support temporary and permanent events.

For both cases, recursion is possible, as is rescheduling

#### Scheduler

Supports calling functions either at some time point or after some delay

### Can We?

We can, of course, do everything that max can do, so it is likely we can anything relatively simply. 

One avenue to ensure this possibility is to use promises to help things along. 

We can also provide additional functionality to the set timeout method. 

The one obstacle we have, however: I do not think that ITM objects allow arguments. 

### Solutions to above obstacle

We can have a dynamic array of "events" storing the time at which the event is to be triggered. This is very lightweight.

Better, a scheduler the encapsulates the above.

We may also have an array of clocks? The issue here is there is no way to determine the timing of things. 

